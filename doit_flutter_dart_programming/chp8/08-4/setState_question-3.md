질문 : `setState(() {})`는 왜 이렇게 생겼는가?

좋아요. `setState(() {})`의 구조가 왜 그렇게 생겼는지, 익명 함수와 콜백 함수가 왜 필요한지까지 포함해서 흐름 있는 설명형 문서 형태로 정리해드릴게요. 잠시만 기다려 주세요.


# Flutter의 `setState(() {})`와 익명 함수, 콜백 함수 이해하기

Flutter에서 UI를 갱신할 때 `setState(() { ... })`와 같은 코드를 자주 쓰게 됩니다. 처음 보면 왜 함수 호출 사이에 또 함수가 들어가 있는지 헷갈릴 수 있습니다. 또한 익명 함수(Anonymous Function)나 콜백(Callback) 함수라는 개념도 등장하는데요, 이 글에서는 **setState의 구조**, **익명 함수의 필요성**, **콜백 함수의 개념**, 그리고 이들이 Flutter 코드에서 어떻게 엮이는지\*\*를 살펴보겠습니다. 예제 코드와 함께 단계별로 설명하니 개발자 관점에서 이해하기 쉬운 블로그 포스트 형식으로 읽어보세요.

## 1. `setState(() {})`의 구조와 동작 원리

Flutter의 `setState`는 **StatefulWidget의 상태를 변경**하고 UI를 다시 그리도록 알려주는 메서드입니다. 이 메서드는 다음과 같은 시그니처를 가집니다:

```dart
@protected
void setState(VoidCallback fn) { ... }
```

즉, `setState`는 `VoidCallback` 타입의 함수(`fn`)를 매개변수로 받습니다. 여기서 \*\*`VoidCallback`\*\*은 Dart에서 `void Function()`의 별칭입니다. 함수 이름 없이 즉석에서 정의한 익명 함수(closure)를 넣기 때문에 코드에 `( )`와 `{ }`가 연달아 등장하는 것입니다.

예를 들어 상태를 1 증가시키는 코드를 쓴다면 `setState(() { count += 1; });`과 같이 작성합니다. 이때 `() { count += 1; }` 부분이 익명 함수이고, 이를 `setState`에 전달하여 상태 변경 작업을 수행하게 됩니다. Flutter 공식 문서에도 setState는 \*\*“제공된 콜백 함수를 동기적으로 호출한 뒤, 해당 위젯 트리를 마크하여 빌드를 다시 수행한다”\*\*고 설명되어 있습니다. 즉, 내부적으로 `fn()`을 실행한 뒤 `Element.markNeedsBuild()`를 호출하여 UI를 갱신합니다.

이렇게 `setState`가 콜백 함수 형태를 취하는 이유 중 하나는 개발자의 **명시적 상태 변경 의도**를 유도하기 위해서입니다. 과거 Flutter는 직접 `markNeedsBuild()` 같은 메서드를 호출했지만, 개발자가 무차별적으로 호출하여 성능에 문제가 생겼습니다. 그래서 API를 콜백으로 변경하였고, 결과적으로 \*\*“상태를 콜백 안에서 업데이트하도록 함으로써, 필요한 시점에만 setState를 호출하게 되어 오용이 줄어들었다”\*\*는 문서상의 분석도 있습니다. 이처럼 `setState(() {})` 구조는 상태 변화 코드를 명확히 드러내어 Flutter 앱의 동작을 직관적으로 만들어 줍니다.

* **setState 시그니처**: `void setState(VoidCallback fn)` (VoidCallback은 `void Function()`의 별칭)
* **동작 원리**: 인자로 받은 콜백을 실행(`fn()`), 그 후 화면 갱신(`markNeedsBuild()`)
* **디자인 취지**: 과거 단순 빌드 트리거 방식보다 콜백 방식을 통해 상태 변경 의도를 명확히 함

## 2. 익명 함수(Anonymous Function)이란?

익명 함수는 **이름이 없는 함수**를 뜻하며, 필요할 때 즉석에서 작성해서 사용할 수 있는 기능입니다. 일반 함수는 보통 `void foo() { ... }`처럼 이름이 있지만, 익명 함수는 바로 `( ) { ... }` 또는 화살표 식 `( ) => ...` 형태로 표현합니다. Dart 공식 문서에도 “대부분의 함수들은 이름이 있지만, 익명 함수(람다, 클로저)는 이름이 없는 함수”라고 설명하고 있습니다.

익명 함수를 쓰는 주요 이유는 **간단한 동작을 일회용으로 전달**하기 위해서입니다. 예를 들어 버튼 클릭, 리스트 순회, 타이머 처리 등 이벤트나 일회성 작업에 콜백으로 함수를 넘겨야 할 때, 별도의 이름을 붙이지 않고 익명 함수를 직접 전달하면 코드가 간결해집니다. 또, 익명 함수는 함수가 선언된 **외부 변수에 접근**(클로저)할 수 있어서, 선언된 범위 내의 상태나 값을 쉽게 사용할 수 있는 장점이 있습니다.

다른 예를 들어 보겠습니다. 리스트의 각 요소에 1을 더하는 코드를 생각해봅시다. 아래와 같이 익명 함수를 직접 전달할 수 있습니다:

```dart
var list = [1, 2, 3];
var incremented = list.map((item) => item + 1); // 익명 함수를 map에 전달
print(incremented); // [2, 3, 4]
```

위 예제에서 `(item) => item + 1`이 익명 함수입니다. 이름을 따로 붙이지 않고도 간단히 함수를 만들 수 있어 코드가 깔끔해집니다. Flutter 위젯의 `onPressed` 같은 콜백에도 마찬가지입니다. 예를 들면:

```dart
ElevatedButton(
  onPressed: () {
    print('버튼이 클릭되었습니다.'); // 익명 함수로 이벤트 핸들러 등록
  },
  child: Text('클릭'),
);
```

이처럼 이벤트 처리나 고차 함수에 사용할 때 익명 함수는 매우 편리합니다. 반면 **일반 함수**(이름 있는 함수)는 재사용할 코드가 많거나, 함수 내용을 여러 곳에서 쓰고 싶을 때 사용합니다. 예를 들어 복잡한 로직이 한 번만 사용된다면 익명 함수를, 여러 군데에서 호출될 로직이라면 일반 함수를 정의하는 식으로 나눌 수 있습니다.

* **익명 함수 특징**: 이름 없이 작성하며, 일회성으로 사용. 외부 변수(상태)를 캡처할 수 있음
* **일반 함수 대비 장점**: 코드가 간결해지고, 다른 곳에 함수명을 추가로 등록할 필요 없음. 이벤트 핸들러나 컬렉션 메서드 인자로 자주 사용.
* **예제**: `(a, b) { return a + b; }` 또는 `(x) => x.toUpperCase()` 같은 람다 식.

## 3. 콜백 함수(callback)의 개념과 역할

**콜백(callback) 함수**란 “다른 함수에 인자로 전달되어 특정 시점이나 이벤트에서 호출되는 함수”를 말합니다. 콜백 함수는 주로 비동기 작업이나 이벤트 처리를 위해 사용됩니다. 예를 들어 **비동기 프로그래밍**에서는 어떤 작업이 완료된 뒤 그 결과를 처리하기 위해 콜백 함수를 넘깁니다. Dart(및 JavaScript 등)에서는 “콜백 함수는 특정 작업이 완료되면 호출되는 함수”라고 설명합니다. 즉, 작업이 끝난 뒤 결과를 받아 처리하거나, 이벤트가 발생했을 때 어떤 행동을 수행하도록 미리 함수를 등록해두는 식입니다.

함수형 프로그래밍 패러다임에서도 콜백(혹은 고차 함수)이 중요합니다. Dart에서는 함수를 일급 객체로 다룰 수 있기 때문에, 다른 함수의 인자로 전달하거나, 변수에 담아서 사용할 수 있습니다. 예를 들어 리스트 순회 메서드인 `forEach`, `map`, `where` 등은 모두 콜백 함수를 인자로 받아서 각 요소에 적용합니다.

Flutter에서는 콜백이 UI 구성에 필수적입니다. 거의 모든 버튼, 제스처 처리, 텍스트 입력 등 위젯은 사용자의 행위에 대응하기 위해 콜백 속성을 가지고 있습니다. 대표적으로 `ElevatedButton` 위젯을 보겠습니다. 공식 API 문서에 따르면 `ElevatedButton`의 생성자는 `required VoidCallback? onPressed`를 매개변수로 받습니다. 즉, 버튼이 눌렸을 때 실행할 함수를 `onPressed`에 전달하는 것입니다. 예를 들면:

```dart
ElevatedButton(
  onPressed: () {
    // 이 익명 함수가 버튼 클릭 이벤트의 콜백으로 동작
    print('버튼이 눌렸습니다.');
  },
  child: Text('클릭'),
);
```

이 코드에서 `() { print(...); }`가 `onPressed` 콜백 함수입니다. 버튼이 눌리면 프레임워크가 이 콜백을 호출해주며, 내부에서 정의한 동작이 수행됩니다.

이 외에도 Flutter에서는 `onTap`, `onChanged`, `onPressed`, `onCompletion` 등 다양한 콜백들이 있으며, `setState` 자체도 콜백을 요구하는 메서드입니다. 즉, 상태 변화를 수행할 함수를 인자로 받아 처리합니다. 이런 방식으로 **이벤트가 발생했을 때 원하는 코드를 유연하게 연결**할 수 있죠.

* **콜백의 정의**: “특정 작업이나 이벤트가 완료된 후 호출되는 함수”. 함수형 프로그래밍의 고차 함수와 관련.
* **Dart/Flutter 활용 예**: 리스트 메서드(`map`, `forEach`), 버튼 이벤트(`onPressed`), 비동기 완료 처리(`Future.then`), 애니메이션 리스너 등.
* **예시**: `ElevatedButton(onPressed: () { ... })` 에서 `onPressed`는 버튼 클릭 시 실행될 콜백 함수.

## 4. 익명 함수→콜백→setState의 관계와 예제

이제 위의 개념들을 결합해보겠습니다. 일반적인 Flutter 코드에서 **익명 함수**를 **콜백으로 전달**하고, 그 콜백을 `setState`가 호출하는 흐름은 다음과 같습니다.

1. **이벤트 발생**: 사용자가 화면의 버튼을 누름.
2. **onPressed 콜백 호출**: Flutter 프레임워크가 `ElevatedButton`의 `onPressed`에 전달된 익명 함수를 실행함. 이 함수는 우리가 정의한 코드 블록입니다.
3. **setState 호출**: onPressed 콜백 내부에서 `setState(...)`를 호출하고, `setState`에 또 다른 익명 함수를 전달함. 예를 들어 상태 변수(`count`)를 증가시키는 코드를 전달할 수 있습니다.
4. **상태 변경과 UI 갱신**: `setState` 내부에서 전달된 익명 함수를 실행하여 실제 상태(`count`)를 변경하고, 그 뒤에 Flutter는 해당 위젯을 다시 빌드하여 화면을 갱신합니다.

아래는 버튼을 눌러 화면의 숫자를 증가시키는 간단한 예제입니다:

```dart
class CounterWidget extends StatefulWidget {
  @override
  _CounterWidgetState createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  int count = 0;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text('Count: $count'), // 현재 카운트를 화면에 표시
        ElevatedButton(
          child: Text('증가'),
          onPressed: () {
            // 1) 버튼 클릭 이벤트의 콜백(익명 함수)
            setState(() {
              // 2) setState에 전달된 콜백(익명 함수) 안에서 상태를 변경
              count++;
            });
          },
        ),
      ],
    );
  }
}
```

위 코드에서 `onPressed: () { ... }` 부분이 **익명 함수**로, 버튼 클릭 시 실행될 콜백입니다. 이 익명 함수 안에서 다시 `setState(() { count++; });`를 호출하고 있습니다. 여기서 `() { count++; }`도 또 다른 익명 함수이며, 이를 `setState`의 매개변수로 전달합니다. 결과적으로 버튼을 누르면 **첫 번째 익명 함수**가 호출되고, 그 안에서 **두 번째 익명 함수**가 실행되어 `count`가 1 증가합니다. 이어서 Flutter가 화면을 갱신하여 변경된 값을 보여주게 됩니다.

* **작동 순서**: 버튼 클릭 → `onPressed` 콜백(익명 함수) 실행 → 내부에서 `setState` 호출 → `setState`의 콜백(익명 함수) 실행 후 UI 재빌드.
* **예시 코드**: 위 Flutter 코드처럼, 익명 함수를 콜백으로 넘기고 `setState`가 그것을 호출하여 상태를 변경.

## 5. 결론: 왜 이 구조가 직관적이고 언제 일반 함수를 쓸까

Flutter의 `setState(() {})` 구조와 콜백/익명 함수 패턴은 다음과 같은 장점이 있습니다. 우선 **명시성**이 높습니다. 상태 변경 코드가 `setState` 블록 안에 모여 있어, 개발자가 “어디에서 UI 상태를 변경했는지” 명확히 드러납니다. `setState` 호출이 곧 상태 변경의 시작이라는 점이 코드상으로도 분명해집니다. 또한 익명 콜백을 사용함으로써 해당 상태 변경이 **특정 이벤트나 위치**에 묶여 있는 형태가 되어, 실행 흐름이 직관적으로 이어집니다.

성능 측면에서도 효율적입니다. Flutter 문서에 따르면 `setState`는 내부에서 **콜백을 즉시 호출한 뒤** `markNeedsBuild`를 실행하므로 비용이 크지 않습니다. (물론 전체 위젯 트리를 다시 빌드하는 간접 비용이 있으므로 **반드시 필요한 경우에만** 호출해야 합니다.) 익명 함수를 사용하면 불필요한 별도의 함수를 정의하지 않아도 되고, 단발성으로 쓰고 버릴 수 있는 경량 객체(클로저)를 사용하므로 런타임 오버헤드도 거의 없습니다.

그렇다면 **언제 익명 함수 대신 일반 함수를 사용할까요?** 답은 **재사용성과 가독성**에 따라 달라집니다. 만약 상태 변경 로직이 여러 곳에서 반복되거나, 콜백 내부 코드가 길어서 복잡하다면 익명 함수 대신 별도의 일반 함수(메서드)로 정의하는 것이 좋습니다. 예를 들어 위 카운터 예제에서 `count++`만 있는 간단한 로직이라면 익명 함수로 충분하지만, 만약 상태를 변경하는 코드가 더 복잡하거나 여러 버튼에서 동일한 로직을 쓰는 상황이라면 `_incrementCounter()` 같은 이름 있는 메서드를 만들어 사용하면 코드를 읽고 관리하기 편합니다.

Flutter는 함수 참조(tear-off)도 지원하므로, 적절한 경우에는 함수 이름만 전달할 수도 있습니다. 예를 들어 다음과 같이 구현할 수 있습니다:

```dart
void _incrementCounter() {
  setState(() {
    count++;
  });
}

// ...

ElevatedButton(
  child: Text('증가'),
  onPressed: _incrementCounter, // 함수 참조 전달
);
```

이 경우 `onPressed`에 함수 이름만 적으면 되므로 코드가 더욱 간결해질 수 있습니다. 다만 이 방법은 전달하려는 함수가 `void Function()` 형태여야 합니다. 그리고 길고 복잡한 코드는 오히려 별도 함수로 작성하는 것이 유지 보수에 유리합니다.

결국 Flutter에서 익명 함수와 콜백, `setState` 조합은 **상태 변경 로직과 이벤트 처리 로직을 깔끔하게 분리하면서 코드 가독성과 효율성을 높여줍니다**. 직관적인 구조 덕분에 개발자는 UI 이벤트에 연동된 상태 업데이트를 명확히 작성할 수 있습니다. 그러나 코드의 재사용성이나 가독성을 위해서는 상황에 따라 일반 함수(메서드)를 쓰는 것이 좋은 선택이 됩니다.

**참고 자료:** Flutter 공식 문서 및 커뮤니티 글에서 `setState` 시그니처와 콜백 동작 원리에 대해 자세히 설명하고 있습니다. (각주된 링크를 참고하세요.)

---

⚠️ "setState()내부에 있기 때문에 void가 반환되면 build()가 setState()에 의해서 실행되는거야?"

→ 여기에는 오해가 있습니다.
void가 반환되기 때문에 build()가 호출되는 것은 아닙니다.

✅ 정확한 동작 순서는 이렇습니다:
setState(() { ... })가 호출된다.
setState는 매개변수로 전달받은 콜백 함수 ( ) { ... }를 즉시 실행한다.
이 함수 안에서 실제로 상태 값이 변경된다.
그 후 setState()는 markNeedsBuild() 메서드를 내부적으로 호출하여 현재 위젯이 리빌드되도록 Flutter 프레임워크에 알린다.
따라서 build()가 자동으로 호출된다.
즉, void 반환이 트리거가 되는 것이 아니라, setState()가 내부에서 빌드를 요청하는 작업을 수행하기 때문에 UI가 갱신되는 것입니다.

---

좋습니다! 그렇다면 지금부터 Flutter의 `State` 클래스 내부에 정의된 `setState()`의 **실제 소스코드** 일부를 바탕으로, 내부 동작이 어떻게 이루어지는지 **깊이 있고 정확하게** 설명드릴게요.

---

## ✅ 1. `State` 클래스의 실제 `setState()` 구현 (요약 버전)

Flutter SDK의 `flutter/lib/src/widgets/framework.dart` 파일에는 다음과 같은 코드가 있습니다:

```dart
@protected
void setState(VoidCallback fn) {
  assert(fn != null);
  _element.markNeedsBuild();  // ⬅️ 여기에서 리빌드 요청
  fn();                       // ⬅️ 전달받은 콜백 함수 실행
}
```

> 최신 버전에서는 순서가 반대일 수 있음: `fn()` 먼저 실행한 뒤 `markNeedsBuild()`를 호출하는 경우도 있음
> → 일반적으로는 `fn()` 실행 → 리빌드 요청 순입니다. 핵심은 **둘 다 실행된다는 것**입니다.

---

## ✅ 2. 각 라인의 의미

```dart
void setState(VoidCallback fn)
```

* `VoidCallback`은 `void Function()` 타입을 의미합니다.
* 즉, 반환값이 `없고`, 매개변수가 `없는 함수`만 전달할 수 있어요.
* `() { ... }` 형태의 익명함수 혹은 정의된 일반함수를 전달할 수 있습니다.

---

```dart
assert(fn != null);
```

* 개발 중 (`assert`) null 안전을 보장하기 위한 코드입니다.
* 전달된 함수가 반드시 존재해야 함을 확인합니다.

---

```dart
fn();
```

* 사용자가 `setState(() { someState = newValue; })` 형태로 전달한 **콜백 함수 본체를 실행**합니다.
* 여기서 실제로 `상태값 변경`이 일어납니다.

---

```dart
_element.markNeedsBuild();
```

* 이 줄이 **진짜 핵심입니다.**
* `_element`는 현재 위젯의 Element 객체이며, `markNeedsBuild()`는 이 위젯을 다시 그려야 한다고 Flutter에게 알리는 메서드입니다.
* 이 호출로 인해 다음 프레임에서 `build()`가 다시 호출됩니다.

---

## ✅ 요약 흐름

```dart
setState(() {
  // 상태 변경
});
```

이 한 줄로 아래 작업이 내부에서 순차적으로 실행됩니다:

1. 전달받은 함수 `( ) { 상태 변경 }` 실행됨 → 실제 데이터 변경
2. `markNeedsBuild()` 호출 → Flutter 프레임워크에게 “이 위젯 다시 그려야 함”이라고 알림
3. 다음 프레임에서 자동으로 `build()` 호출됨 → UI 갱신

---

## ✅ 왜 `return 값`이 없어도 되는가?

* `setState()`는 우리가 전달한 콜백 함수의 **반환값에 전혀 관심이 없습니다.**
* 오직 **콜백 함수 안에서 상태가 바뀌었는지 여부**와
* 그리고 **리빌드 요청 (`markNeedsBuild`)이 이루어졌는지**만 중요합니다.

---

## ✅ 정리

| 요소                 | 설명                                 |
| ------------------ | ---------------------------------- |
| `setState(fn)`     | 상태 변경을 알리고, 리빌드를 요청하는 Flutter의 API |
| `fn()`             | 실제 상태값을 바꾸는 함수 (익명/일반함수 모두 가능)     |
| `markNeedsBuild()` | Flutter에게 “UI 다시 그려줘” 요청           |
| `build()`          | 상태 변경 후 자동으로 다시 호출되는 메서드           |

---

좋습니다! 이전에 설명드린 내용을 바탕으로, Flutter의 `setState()`와 그 내부에서 호출되는 `markNeedsBuild()` 메서드의 동작 원리를 더욱 깊이 있게 살펴보겠습니다. 이 과정을 통해 Flutter의 상태 관리와 UI 갱신 메커니즘을 명확히 이해하실 수 있을 것입니다.


## 🔍 `setState()`의 내부 동작

Flutter에서 `setState()`는 상태를 변경하고 UI를 갱신하는 데 사용되는 핵심 메서드입니다. 이 메서드는 다음과 같은 순서로 동작합니다:

1. **콜백 함수 실행**: `setState()`에 전달된 콜백 함수가 즉시 실행되어 상태를 변경합니다.
2. **`markNeedsBuild()` 호출**: 상태 변경 후, 해당 위젯의 `Element`에 대해 `markNeedsBuild()`를 호출하여 UI 갱신을 요청합니다.

이 과정을 통해 Flutter는 변경된 상태를 반영하여 UI를 재구성합니다.

---

## 🧠 `markNeedsBuild()`의 역할

`markNeedsBuild()`는 Flutter 프레임워크의 `Element` 클래스에 정의된 메서드로, 위젯의 UI를 다시 그려야 함을 프레임워크에 알리는 역할을 합니다. 이 메서드는 다음과 같은 작업을 수행합니다:

* **위젯을 'dirty' 상태로 표시**: 해당 위젯이 변경되었음을 나타내어, 다음 프레임에서 다시 빌드되도록 합니다.
* **전역 빌드 목록에 추가**: 변경된 위젯을 전역 빌드 목록에 추가하여, 프레임워크가 이를 감지하고 재구성할 수 있도록 합니다.

이러한 메커니즘을 통해 Flutter는 효율적으로 UI를 갱신합니다.

---

## ⚠️ 주의사항: 빌드 중 `setState()` 호출

Flutter에서는 위젯의 빌드 과정 중에 `setState()`를 호출하는 것을 권장하지 않습니다. 이는 다음과 같은 이유로 인해 오류를 발생시킬 수 있습니다:

* **빌드 중 상태 변경 금지**: 빌드 과정은 UI를 구성하는 중요한 단계로, 이 과정 중에 상태를 변경하면 예기치 않은 동작이나 오류가 발생할 수 있습니다.
* **오류 메시지 예시**: "setState() or markNeedsBuild() called during build"와 같은 오류가 발생할 수 있습니다.

이러한 문제를 방지하기 위해, 상태 변경은 빌드 과정이 완료된 후에 수행하는 것이 좋습니다.

---

## ✅ 안전한 상태 변경 방법

빌드 과정이 완료된 후에 상태를 변경하려면, 다음과 같은 방법을 사용할 수 있습니다:

```dart
WidgetsBinding.instance.addPostFrameCallback((_) {
  setState(() {
    // 상태 변경 코드
  });
});
```

이 코드는 현재 프레임의 빌드가 완료된 후에 콜백 함수를 실행하여, 안전하게 상태를 변경하고 UI를 갱신할 수 있도록 합니다.

---

## 🧾 요약

* `setState()`는 상태 변경 후 `markNeedsBuild()`를 호출하여 UI 갱신을 요청합니다.
* `markNeedsBuild()`는 해당 위젯을 'dirty' 상태로 표시하고, 다음 프레임에서 다시 빌드되도록 합니다.
* 빌드 과정 중에 `setState()`를 호출하면 오류가 발생할 수 있으므로, 상태 변경은 빌드 완료 후에 수행해야 합니다.
* `WidgetsBinding.instance.addPostFrameCallback()`을 사용하여 빌드 완료 후에 상태를 안전하게 변경할 수 있습니다.

이러한 메커니즘을 이해하면, Flutter에서의 상태 관리와 UI 갱신 과정을 보다 명확하게 파악할 수 있습니다. 추가로 궁금하신 점이나 더 깊이 있는 설명이 필요하시면 언제든지 말씀해주세요!
