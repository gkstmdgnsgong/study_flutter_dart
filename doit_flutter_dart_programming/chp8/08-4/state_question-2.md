//165p 질문

질문 : 그렇다면 효율성을 위해 StatefulWidget은 매번 객체를 StatelessWidget처럼 다시 생성하지만 State는 예외적으로 다시 생성되지 않는 것으로 알고 있어, 이유는 상태 즉, 데이터와 로직이 복잡하고 무겁기 때문이지? 이것이 맞을까? 그렇다면 State는 변경되지 않고 setState는 State를 제외한 ui를 다시 빌드하기 위함이라고 이해해도 될까? 엄밀하게 따져줘

아주 깊이 있는 질문입니다. 말씀하신 내용은 **전반적으로 정확한 이해**에 가까우며, 몇 가지 개념을 **엄밀히 정리**해드리면 다음과 같습니다:

---

## ✅ 정리: `StatefulWidget`, `State`, 그리고 `setState()`의 관계와 동작

### 1. ✅ `StatefulWidget`은 "가벼운 위젯"이고, UI 트리에 자주 새로 생성된다.

* `StatelessWidget`과 마찬가지로 `StatefulWidget`은 \*\*불변(immutable)\*\*입니다.
* UI 트리에서 변경이 감지되면 **새로운 `StatefulWidget` 객체**가 생성되고, 기존 위젯과 `==` 비교하여 변경 여부가 평가됩니다.
* 중요한 점은 **StatefulWidget은 UI를 위한 껍데기일 뿐**이고, 진짜 상태와 로직은 `State` 객체에 들어 있다는 것!

> 🔸 그래서 StatefulWidget은 자주 새로 생성되어도 부담이 없습니다.

---

### 2. ✅ `State` 객체는 무거울 수 있고, 계속 유지됩니다.

* `State`는 사용자 상호작용, 애니메이션 상태, 내부 변수 등 **변경 가능한 상태를 보존**합니다.
* 그래서 Flutter는 **한 번 연결된 `State` 객체를 버리지 않고 재사용**합니다.
* 이건 성능(효율성) 때문이기도 하고, **상태 보존의 일관성 유지** 때문이기도 합니다.

> 🔸 Flutter는 내부적으로 `StatefulElement`를 통해 `StatefulWidget`과 `State`를 연결하여 트리 구조에서 일관되게 관리합니다.

---

### 3. ✅ `setState()`는 `State` 자체를 바꾸는 것이 아니라, UI를 갱신 요청하는 트리거

* `setState()`는 **UI가 상태의 변경을 반영하도록 build()를 다시 호출**하게 만듭니다.
* 하지만 `State` 인스턴스 자체는 **그대로 유지**됩니다.
* 따라서 `setState()`는 "State를 바꾼다"기보다는, **State 안의 데이터를 바꾼 후 Flutter에게 UI를 다시 그리라고 요청**하는 함수입니다.

```dart
setState(() {
  counter++; // 내부 데이터 변경
}); // 이 시점에 build()가 다시 호출됨
```

> 🔸 즉, `setState()`는 내부 상태(예: 변수 값)을 개발자가 바꾼 다음, 그 변경을 UI에 반영하는 트리거 역할

---

## 🧠 요약하자면

| 항목                | 설명                                              |
| ----------------- | ----------------------------------------------- |
| `StatefulWidget`  | UI 구조만 담당하는 "불변 객체", 자주 새로 생성돼도 부담 없음           |
| `State`           | 상태(데이터)를 보관하는 객체, 한 번 생성되면 그대로 유지됨              |
| `setState()`      | 상태의 변경을 UI에 반영하도록 Flutter에게 알리는 트리거             |
| 왜 State는 재사용?     | 데이터가 복잡하고 무겁기 때문 + 일관성을 유지해야 하므로                |
| `setState()`는 무엇? | 상태 값을 바꾼 다음, 그 결과를 반영하기 위해 build() 호출을 유도하는 메서드 |

---

## 🎯 결론 (질문에 대한 엄밀한 답)

> **Q1. StatefulWidget은 매번 다시 생성되고, State는 유지된다. 왜?**

* 맞습니다. **StatefulWidget은 lightweight이고 불변**이며,
* **State는 상태를 보존하는 무거운 객체이므로 재사용됨**.

> **Q2. State는 변경되지 않고, setState는 State를 제외한 UI만 다시 빌드하는가?**

* **부분적으로 맞지만 엄밀히 말하자면**,
  `setState()`는 **State 객체 내 데이터를 변경하고**,
  **그 변경 사항이 반영된 새로운 UI를 빌드하도록 지시하는 것**입니다.
* 즉, `State` 자체는 **그대로 유지되지만**, `build()`는 **다시 실행**되어 UI만 재구성됩니다.
