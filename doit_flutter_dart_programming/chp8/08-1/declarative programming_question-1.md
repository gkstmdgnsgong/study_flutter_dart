아주 좋은 질문입니다.
\*\*불변성(immutability)\*\*과 \*\*선언형 프로그래밍(declarative programming)\*\*은 **서로 강하게 연결**되어 있으며, 특히 **Flutter**와 같은 선언형 UI 프레임워크에서는 **불변성이 동시성 오류를 줄이는 구조적 기반**이 됩니다.

아래에 **기술 면접 수준으로 엄밀하게 설명**드립니다.

---

## ✅ 선언형 프로그래밍과 불변성의 관계

| 선언형 프로그래밍이란? | 상태를 “어떻게 바꿀지”가 아니라, “무엇을 보여줘야 할지”를 선언하는 프로그래밍 방식입니다. |
| ------------ | ---------------------------------------------------- |
| 불변성이란?       | 데이터나 객체가 한 번 생성되면 더 이상 변경되지 않는 성질을 말합니다.             |

### 📌 선언형 UI의 핵심 특징

* 화면은 "상태(state)의 함수(function)"이다 → `UI = f(state)`
* 상태가 바뀌면 **전체 UI를 재구성**(`rebuild`)
* 이전 상태와 현재 상태를 비교(diffing)하거나, 새로운 위젯 트리를 렌더링

### 📌 이때 **불변성은 어떤 역할**을 하나?

| 역할                 | 설명                                                  |
| ------------------ | --------------------------------------------------- |
| 🔄 예측 가능한 리렌더링     | 상태가 불변이면, 상태가 바뀌면 “무조건 새 객체” → 어떤 상태인지 명확           |
| 🧩 비교(diff)가 간단    | 참조 비교(`==`)만으로 상태 변화 감지 가능 (`oldState != newState`) |
| 🔒 동시성 안전성         | 상태를 복사해 새로 만들기 때문에 다른 함수나 쓰레드가 해당 상태를 변경할 수 없음      |
| 🧼 Side effect 최소화 | 이전 상태에 영향을 주지 않음 → side effect나 버그 발생 확률 낮음         |

---

## 🔄 명령형(Imperative) vs 선언형(Declarative) 비교

| 구분    | 명령형 프로그래밍                      | 선언형 프로그래밍                                  |
| ----- | ------------------------------ | ------------------------------------------ |
| 접근 방식 | “어떻게” 바꿀지를 일일이 명시              | “무엇”이 되어야 하는지를 선언                          |
| 상태 관리 | 가변 객체(mutable) 사용 → 상태 직접 변경   | 불변 객체 사용 → 새 객체로 상태 전이                     |
| 위험    | race condition, side effect    | 동시성 안정성 높음                                 |
| 예시    | `setState(() { count += 1; })` | `state = state.copyWith(count: count + 1)` |

---

## ✅ Flutter에서 실제 예시

```dart
// 선언형 UI
class CounterWidget extends StatelessWidget {
  final int count;
  const CounterWidget(this.count);

  @override
  Widget build(BuildContext context) {
    return Text('Count: $count');
  }
}
```

이 위젯은 `count`가 바뀔 때마다 새로 build되지만, **내부적으로는 불변성을 유지**하므로 동시성 문제가 발생하지 않습니다.

---

## ✅ 핵심 면접 답변 예시

> 선언형 UI는 상태를 기반으로 전체 UI를 재구성하기 때문에, 상태는 불변(immutable)일수록 예측 가능하고 안전하게 리렌더링할 수 있습니다. 특히 Flutter 같은 프레임워크에서는 상태 변경이 곧 객체 교체를 의미하며, 이 방식은 side effect와 concurrency 문제를 효과적으로 차단합니다.